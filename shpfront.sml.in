(* m4_divert(0)dnl *)

structure TypeUtils = struct
  fun isEntier s =
        let
          val dropMinus = case explode s of #"-"::cs => cs | cs => cs
        in
          List.all Char.isDigit dropMinus
        end
  fun isDouble s =
        case Real.fromString s of
             NONE => false
           | SOME _ =>
               not (Substring.isSubstring "~" (Substring.full s))
  fun isTrue "TRUE" = true
    | isTrue "True" = true
    | isTrue "true" = true
    | isTrue _      = false
  fun isFalse "FALSE" = true
    | isFalse "False" = true
    | isFalse "false" = true
    | isFalse _       = false
end

structure EncodingIO = struct
  fun execForOutput args =
        let
          fun mkInstream fd =
                let
                  val reader = Posix.IO.mkTextReader
                      {fd = fd, name = "", initBlkMode = true}
                  val instream = TextIO.StreamIO.mkInstream (reader, "")
                in
                  instream
                end
          val c2p = Posix.IO.pipe ()
        in
          case Posix.Process.fork () of
               NONE => (* child *)
                 let
                   val cmd = hd args
                 in
                   Posix.IO.dup2 {old = #outfd c2p, new = Posix.FileSys.stdout};
                   Posix.IO.close (#infd c2p);
                   Posix.Process.execp (cmd, args)
                 end
             | SOME pid => (* parent *)
                 let
                   val ins = mkInstream (#infd c2p)
                 in
                   Posix.IO.close (#outfd c2p);
                   ins
                 end
        end

  fun openIn (fileName, encoding) =
        let
          val args = [["shpconv.tcl", "-encoding", encoding, fileName]]
          val ins = execForOutput args
        in
          ins
        end

  fun getStdIn encoding =
        let
          val args = [["shpconv.tcl", "-encoding", encoding]]
          val ins = execForOutput args
        in
          ins
        end

end

structure AwkReader = struct
  open TypeUtils

  fun escapeAndPrint s =
        let
          val s = Substring.full s
          fun p #"\"" = print "\\\""
            | p c = TextIO.output1 (TextIO.stdOut, c)
        in
          Substring.app p s
        end
  fun awkRead ins =
        let
          fun println s = (print s; print "\n")
          val scan = CSV.scanAwk TextIO.StreamIO.input1
          fun loop ins =
                case scan ins of
                     NONE => ()
                   | SOME (record, ins) =>
                       let
                         fun emitField field = (
                               if isEntier field then
                                 print field
                               else if isDouble field then
                                 print field
                               else if isTrue field then
                                 print "true"
                               else if isFalse field then
                                 print "false"
                               else (
                                 print "{%str \"";
                                 escapeAndPrint field;
                                 print "\"}");
                               print " ")
                       in
                         List.app emitField record;
                         print "\n";
                         loop ins
                       end
        in
          loop ins
        end
end

structure SheepFront = struct
  fun fail msg = raise Fail msg
  fun parseOptions args =
        let
          fun parse (options, "-encoding"::args) =
                (case args of
                      [[]] => fail "-encoding requires an argument"
                    | encoding::args =>
                        let
                          val options = {
                                encoding = encoding,
                                format = #format options,
                                options = #options options }
                        in
                          parse (options, args)
                        end)
            | parse (options, "-format"::args) =
                (case args of
                      [[]] => fail "-format requires an argument"
                    | format::args =>
                        let
                          val options = {
                                encoding = #encoding options,
                                format = format,
                                options = #options options }
                        in
                          parse (options, args)
                        end)
            | parse (options, "-opts"::args) =
                (case args of
                      [[]] => fail "-opts requires an argument"
                    | opts::args =>
                        let
                          val options = {
                                encoding = #encoding options,
                                format = #format options,
                                options = opts }
                        in
                          parse (options, args)
                        end)
            | parse (options, "--"::args) =
                (options, args)
            | parse (options, arg::args) =
                if String.isPrefix "-"  arg
                then fail ("unknown option: " ^ arg)
                else (options, arg::args)
            | parse (options, [[]]) =
                (options, [[]])
        in
          parse ({encoding = "utf-8", format = "awk", options = ""}, args)
        end

  fun main () =
        let
          val (options, args) = parseOptions (CommandLine.arguments ())
        in
          if length args > 0 then
            let
              fun f fileName =
                    let
                      val ins = EncodingIO.openIn (fileName, #encoding options)
                      fun release () = TextIO.StreamIO.closeIn ins
                    in
                      (AwkReader.awkRead ins; release ())
                      handle e => (release (); raise e)
                    end
            in
              List.app f args
            end
          else
            let
              val ins = EncodingIO.getStdIn (#encoding options)
              fun release () = TextIO.StreamIO.closeIn ins
            in
              (AwkReader.awkRead ins; release ())
              handle e => (release (); raise e)
            end
        end

end

fun main () = SheepFront.main ()

val () = main ()
